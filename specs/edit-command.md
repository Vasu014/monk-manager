# Edit Command Specification

## Overview
The `edit` command allows users to request code modifications within a specified file using an AI model. The model will suggest changes in a unified diff format, which can then be applied to the file.

## Command Syntax
The primary way to invoke the command:
```bash
monk-manager edit --file <FILE_PATH> [OPTIONS]
```
Alternatively, for files in the current directory or specified by relative path:
```bash
monk-manager edit <FILE_PATH_RELATIVE> [OPTIONS]
```
Upon execution, the CLI will prompt the user to enter their detailed instructions for the code modification.

## Arguments and Options

*   `<FILE_PATH>` / `<FILE_PATH_RELATIVE>`: (Required) The path to the file that needs to be edited. This path will be resolved relative to the repository home directory set during the initial CLI setup (see `specs/cli.md`).
*   `--dry-run`: (Optional) If present, the command will output the generated diff to the console but will not apply it to the file.
*   `--auto-apply`: (Optional) If present, the changes will be applied automatically without user confirmation. (Use with caution).

## Workflow

1.  **User Invocation**: The user invokes `monk-manager edit` with the target file.
2.  **Prompt Input**: The CLI prompts the user to enter their detailed problem statement or request for changes. The user can type a multi-line prompt and typically finalizes it with a specific sequence (e.g., Ctrl+D on a new line, or typing a specific keyword).
3.  **File Selection & Validation**:
    *   The CLI resolves the `<FILE_PATH>` relative to the established repository home.
    *   It verifies that the file exists and is readable.
4.  **Contextualization**:
    *   The content of the `<FILE_PATH>` is read.
    *   (Future enhancement) Relevant context from other project files (within the repository home) might be gathered if the AI model needs broader understanding.
5.  **AI Interaction**:
    *   The file content and the user's detailed prompt (collected in step 2) are sent to the configured AI model.
    *   The AI model is specifically instructed to provide its suggested changes in the **unified diff format (`udiff`)**.
6.  **Diff Reception**: The AI returns the proposed changes as a `udiff` string.
7.  **Change Application (Conceptual Tool: `edit_file`)**:
    *   `monk-manager` receives the `udiff`.
    *   An internal function, let's call it `apply_patch(file_path: &str, diff_content: &str) -> Result<(), Error>`, will be responsible for applying this `udiff` to the specified `file_path`.
    *   While this function is internal to `monk-manager`, the AI's response (the `udiff`) is the "output" that this conceptual tool would "apply."
8.  **User Confirmation (Default Behavior)**:
    *   Unless `--auto-apply` is used, the generated `udiff` is displayed to the user (e.g., in the console with appropriate highlighting).
    *   The user is prompted to confirm whether to apply the changes (e.g., "Apply these changes? [y/N/d(etails)]" - where 'details' could show the diff again or more context).
9.  **File Modification**:
    *   If the user confirms (or if `--auto-apply` is active and `--dry-run` is not), the `apply_patch` function attempts to patch the target file.
10. **Output**:
    *   If `--dry-run` is used, the `udiff` is printed to standard output, and no actual file changes are made.
    *   A confirmation message indicating success or failure of the file modification is shown to the user. If an error occurs during patching (e.g., diff does not apply cleanly), it is reported.

## AI Model Instructions & `edit_file` Tool

The core idea is that the LLM's task is to **generate a `udiff`**. The `edit_file` functionality is how `monk-manager` acts on that `udiff`.

When interacting with the AI, `monk-manager` will provide:
*   The content of the target file.
*   The user's detailed prompt.
*   A clear directive to return changes *only* in the unified diff format.

Example of what `monk-manager` might send to the LLM (simplified):
```
Context: You are an AI assistant that helps modify code.
File to edit: path/to/user/file.py
File content:
---
<content of file.py>
---
User request: "<USER_ENTERED_MULTILINE_PROMPT>"

Your task is to provide the necessary modifications to this file in the unified diff format.
Ensure your output is ONLY the udiff.
```

**Internal `apply_patch` function:**
This function is part of `monk-manager`'s codebase, not a tool the LLM calls directly via an API during its generation step. The LLM *generates the data* (the udiff) that this function consumes.

*   **Input**:
    *   `file_path: &str`: Path to the file to be patched.
    *   `diff_content: &str`: The `udiff` string generated by the LLM.
*   **Process**:
    1.  Validate the `diff_content` to ensure it's a parsable `udiff`.
    2.  Read the current content of `file_path`.
    3.  Attempt to apply the patch. A Rust crate like `patch` can be used for this.
    4.  If successful, write the modified content back to `file_path`.
*   **Output**: `Result<(), ErrorType>` indicating success or describing the failure (e.g., patch application failed, I/O error).

## Error Handling Specific to Edit Command
*   Target file not found or not accessible.
*   AI model returns data not in `udiff` format.
*   The `udiff` provided by the AI does not apply cleanly to the current file content (e.g., context mismatches).
*   Permissions errors when attempting to write the modified file.
*   Errors from the `patch` utility/library.

## Future Considerations
*   Support for multi-file changes (this would significantly complicate how files and diffs are presented to/from the AI).
*   Interactive diff review and selective application of hunks within the `monk-manager` CLI.
*   Integration with version control:
    *   Automatically creating a new branch before applying changes.
    *   Committing changes with a message derived from the user prompt.
*   Allowing the AI to request reading other files for more context before generating a diff (would require a more conversational flow).
*   A mechanism for the AI to indicate if it cannot fulfill the request or if the request is ambiguous. 